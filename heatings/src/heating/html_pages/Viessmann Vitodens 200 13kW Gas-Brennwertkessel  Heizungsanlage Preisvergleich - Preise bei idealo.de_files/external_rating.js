// Creates an updater with two methods. One to register ids that needs to be updated,
// and one to start the update process.
//
// Updates all registered ids in a (long) regular interval. Also tries to update
// invalid ids in a (short) interval after start and after each regular interval.
// You must specify the maxmial attempts to update invalid ids.
//
// The regular interval should be significantly larger than the product of the
// invalid interval and the maximal attempts added by the first interval.
//
// If you specify a non-positive regular update interval, no regular update will
// occur.
//
// Parameters:
//   element - element type to update
//   prefix - prefix to detect elements to update
//   guardSelector - selector to detect elements that do not need to be updated again
//   baseURL - the base URL to load the boiler plates
//   urlRelplacement - the part of the base url that must be replaced
//   urlPrefix - the prefix to append first to the base URL
//   urlSeparator - separates the registered ids in the URL
//   firstInterval - the period to wait until the first update of invalid ids in milliseconds
//   invalidInterval - the period to wait between updating invalid ids in milliseconds
//   maxAttempts - the maximal number of updates for invalid ids after start and a regular interval
//   regularInterval - the interval to update all elements in milliseconds

function Updater(element, prefix, guardSelector, baseURL, urlReplacement, urlPrefix, urlSeparator, firstInterval, invalidInterval, maxAttempts, regularInterval) {

	// A standard URL generator. Replaces a replacement-string from a base URL by
	// string generated from a list of identifiers. The generated string consists of
	// specified prefix and a specified separator between the identifiers.
	function stdUrlGenerator(baseUrl, idList, replacement, prefix, separator) {
		return baseUrl.replace(replacement, prefix + escape(idList.join(separator)));
	}

	// A standard selector generator. Generates a selector for an identifier by adding a
	// specified prefix surrounded by a '#' and '-'
	function stdSelectorGenerator(id, prefix) {
		return prefix + id;
	}

	// calls functor now or after the first sleep time, sleeping sleepTime after each call, endlessly
	function installLoop(functor, sleepTimeMillis, callNow) {
		var loop = function () {
			functor();
			setTimeout(loop, sleepTimeMillis);
		};
		if (callNow) {
			loop();
		} else {
			setTimeout(loop, sleepTimeMillis);
		}
	}

	// calls functor after the first sleep time, sleeping sleepTime after each call, until maxCalls has been reached
	function installLoopWithMaxCalls(functor, firstSleepTimeInMillis, sleepTimeMillis, maxCalls) {
		var i = 0;
		var loop = function () {
			if (i < maxCalls) {
				i++;
				functor();
				setTimeout(loop, sleepTimeMillis);
			} else {
				// at the end of all loops trigger resize of the window to trigger fn calls linked to the layout
				$(window).trigger('resize');
			}
		};
		setTimeout(loop, firstSleepTimeInMillis);
	}

	// For each identifier in the list a selector is generated by a selector generator and
	// if there is a matching element in both jquery docs, then replaces the one in doc1 with
	// the one from doc2. If the one in doc2 does not contain an element identifiable by a
	// guard selector the id will be put in the result list. Otherwise the guard element
	// will be removed.
	function replaceElements(idList, selectorGenerator, doc1, doc2, guardSelector) {
		if (idList.length === 0) {
			return idList;
		}

		var keepList = [];
		for (var pos = 0; pos < idList.length; pos++) {
			var selector = selectorGenerator(idList[pos]);
			var otherElement = doc2.find(selector);
			if (otherElement.length > 0) {
				var element = doc1.find(selector);
				if (element.length > 0) {
					var validElement = otherElement.find(guardSelector);
					if (validElement.length > 0) {
						validElement.remove();
					} else {
						keepList.push(idList[pos]);
					}
					for (var i = 0; i < element.length; i++) {
						jQuery(element[i]).replaceWith(otherElement.clone());
					}
				}
			} else {
				keepList.push(idList[pos]);
			}
		}
		return keepList;
	}

	// 1) Fetches doc2 from remote URL and iff its available, then
	// 2) calls replaceElements with the result as doc2.
	function replaceElementsFromURL(idList, selectorGenerator, doc1, urlGenerator, guardSelector) {
		if (idList.length === 0) {
			return idList;
		}

		var updateUrl = urlGenerator(idList);
		jQuery.ajax({
			url: updateUrl,
			beforeSend: function(xhr) {
				try {
					xhr.overrideMimeType('text/html; charset=UTF-8');
				} catch(e) {
					// ignore IE-Failures
				}
			},
			dataType: 'html',
			ifModified: true,
			timeout: 5000,
			complete: function (res, status) {
				if (status === 'success') {
					var doc2 = jQuery('<div />').append(res.responseText);
					invalidIdList = replaceElements(idList, selectorGenerator, doc1, doc2, guardSelector);
				}
			}
		});
	}

	var selectorPrefix = element + '.' + prefix + '-';
	var invalidIdList = [];
	var allIdList = [];

	// register ids with this method
	function registerId(id) {
		var pos;
		if (jQuery.inArray(id, allIdList) === -1) {
			allIdList.push(id);
			// check if all are already valid
			var elements = jQuery.find(selectorPrefix + id);
			for (pos = 0; pos < elements.length; pos++) {
				var validElement = jQuery(elements).find(guardSelector);
				if (validElement.length > 0) {
					validElement.remove();
					return;
				} else {
					if (jQuery.inArray(id, invalidIdList) === -1) {
						// not valid -> update later in short intervals
						invalidIdList.push(id);
					}
				}
			}
		}
	};

	// start the update process with this method
	this.start = function() {
		jQuery(element + '[class|=' + prefix + ']').each(function(index) {
			registerId(jQuery(this).attr('class').substr(prefix.length + 1));
		});

		var doc = jQuery(document);

		var urlGenerator = function(idListCur) {
			return stdUrlGenerator(baseURL, idListCur, urlReplacement, urlPrefix, urlSeparator);
		};

		var selectorGenerator = function(idCur) {
			return stdSelectorGenerator(idCur, selectorPrefix);
		};

		var updateInvalidFunctor = function() {
			replaceElementsFromURL(invalidIdList, selectorGenerator, doc, urlGenerator, guardSelector);
		};

		installLoopWithMaxCalls(updateInvalidFunctor, firstInterval, invalidInterval, maxAttempts);

		var updateAllFunctor = function() {
			replaceElementsFromURL(allIdList, selectorGenerator, doc, urlGenerator, guardSelector);
			installLoopWithMaxCalls(updateInvalidFunctor, firstInterval, invalidInterval, maxAttempts);
		};

		if (regularInterval > 0) {
			installLoop(updateAllFunctor, regularInterval, false);
		}
	};
}
